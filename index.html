<!DOCTYPE html>
  <html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Birthday Game - Sketchy Mode</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: monospace;
            touch-action: none;
            user-select: none;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .screen.active { display: flex; }

        /* FIXED: Added background color for Start and Tutorial screens here */
        #screen-start, #screen-tutorial {
            background-color: #f6e6ff; /* Very light magenta/indigo */
        }

        .asset-box {
            position: relative;
            background-color: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: transparent;
            font-size: 11px;
            font-weight: bold;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        .asset-box.loaded {
            background-color: transparent;
            border: none;
            color: transparent; 
        }

        .btn {
            cursor: pointer;
            background-color: rgba(0, 0, 255, 0.1);
            border-color: blue;
            color: blue;
            z-index: 1000;
            transition: transform 0.1s, background-color 0.1s;
        }
        .btn:hover {
            /* background-color: rgba(0, 0, 255, 0.3); */
        }
        .btn:active {
            transform: scale(0.95);
            /* background-color: rgba(0, 0, 255, 0.5); */
        }

        .jitter {
            animation: jitter 0.25s infinite steps(2);
        }
        @keyframes jitter {
            0%   { transform: translate(1px, 1px) rotate(0deg); }
            25%  { transform: translate(-1px, -2px) rotate(-1deg); }use
            50%  { transform: translate(-2px, 0px) rotate(1deg); }
            75%  { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(-1px, 1px) rotate(-1deg); }
        }
        
        .shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97);
        }
        @keyframes shake {
            10%, 90% { transform: translate(-3px, 0); }
            20%, 80% { transform: translate(3px, 0); }
            30%, 50%, 70% { transform: translate(-3px, 0); }
            40%, 60% { transform: translate(3px, 0); }
        }
        
        .flash {
            animation: flash 0.3s;
        }
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .pop {
            animation: pop 0.2s ease-out;
        }
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(0); opacity: 0; }
        }

        .count-anim {
            animation: countPop 0.8s ease-out forwards;
        }
        @keyframes countPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            40% { transform: translate(-50%, -50%) scale(1.0); }
            80% { transform: translate(-50%, -50%) scale(1.0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 98vw;
            max-width: none;
            height: 50px;
            z-index: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            pointer-events: none;
        }
        
        .hud > * {
            pointer-events: none;
        }

        #screen-game {
            background-color: #f6e6ff;
        }

        .game-window {
            position: relative;
            width: 98vw;
            max-width: none;
            height: calc(100vh - 90px);
            margin-top: 70px;
            margin-bottom: 10px;
            border: 2px dashed rgba(200, 180, 220, 0.4);
            border-radius: 15px;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 0 15px rgba(200, 180, 220, 0.2);
        }

        /* Tutorial Text Styling */
        .tut-text {
            font-size: 20px;
            color: #4a1a6a; /* Dark purple for text */
            text-align: center;
            white-space: pre-wrap;
            line-height: 1.5;
            padding: 20px;
            background: transparent;
            border-radius: 0px;
            border: none;
            max-width: 90%;
        }

        #health-fill {
            
            z-index: -1;
            position: absolute;
            left: 0px;
            top: 0px;
            bottom: 0px;
            width: 90%;
            overflow: hidden; 
            transition: width 0.3s;
            border-radius: 3px;
        }

        /* The image fill */
        #health-fill::before {
            content: "";
            position: absolute;
            inset: 0;
            background: url('assets/ui/health_fill.png') no-repeat;
            background-size: cover;
        }

    </style>
</head>
<body>

    <div id="hud" class="hud" style="display:none;">
        <div id="ui-health" class="asset-box" style="width:50vw; max-width:250px; height:50px; position: relative;">
            assets/ui/health_bar.png
            <div id="health-fill"></div>
        </div>
        <div style="font-size:28px; font-weight:400; color:#8a6a9a; font-family: 'Arial', 'Helvetica', sans-serif; text-shadow: 1px 1px 3px rgba(255,255,255,0.9);"><span id="timer">0</span>s</div>
    </div>

    <!-- <div id="screen-loading" class="screen active" style="background: #f6e6ff; display: flex; flex-direction: column; align-items: center; justify-content: center;">
        <div class="tut-text" style="font-size: 24px; text-align: center;">
            Loading...
        </div>
    </div> -->

    <div id="screen-loading" class="screen active" style="background: #f6e6ff;">
        <div style="display:flex; flex-direction:column; gap:30px; align-items:center;">
            <div id="loading-asset" class="asset-box jitter" style="width:200px; height:200px;">assets/ui/loading.png</div>
        </div>
    </div>

    <div id="screen-start" class="screen">
        <div style="display:flex; flex-direction:column; gap:30px; align-items:center;">
            <div id="title-art" class="asset-box jitter" style="width:90vw; height:50vw; max-height: 300px;">assets/ui/title.png</div>
            <div id="btn-start" class="asset-box btn jitter" style="width:70vw; height:25vw; max-width: 400px; max-height: 120px;">
                START GAME<br>(assets/ui/btn_start.png)
            </div>
        </div>
    </div>

    <div id="screen-tutorial" class="screen" style="background-size: cover; background-position: center; background-repeat: no-repeat;">
        <div style="display:flex; flex-direction:column; gap:30px; align-items:center; justify-content: center; width: 100%; height: 100%;">
            <div id="tut-text" class="tut-text jitter">
                Loading...
            </div>
            <div id="btn-ready" class="asset-box btn jitter" style="width:65vw; height:22vw; max-width: 350px; max-height: 110px;">
                I'M READY<br>(assets/ui/btn_ready.png)
            </div>
        </div>
    </div>

    <div id="screen-game" class="screen">
        <div class="game-window" id="game-window"></div>
    </div>

    <div id="screen-end" class="screen" style="background: white;">
        <div style="display:flex; flex-direction:column; gap:20px; align-items:center; padding: 20px;">
            <!-- <h1 style="font-size: 32px; margin-bottom: 10px;">Happy Birthday!</h1> -->
            <div id="final-art" class="asset-box jitter" style="width:80vw; height:100vw; max-width: 400px; max-height: 50vh;">assets/ui/final_art.png</div>
            <h2 id="end-score" class="jitter" style="font-size: 32px; font-weight: 500; color: #333;">Score: 0</h2>
            <div id="btn-replay" class="asset-box btn jitter" style="width:220px; height:90px; margin-top: 10px;">REPLAY</div>
        </div>
    </div>

<script>
const ASSETS = {
    // 'bg_start':    { path: 'assets/ui/bg_start.png' }, // REMOVED per request
    'loading':     { path: 'assets/ui/loading.png' },
    'title':       { path: 'assets/ui/title.png' },
    'btn_start':   { path: 'assets/ui/btn_start.png' },
    'btn_ready':   { path: 'assets/ui/btn_ready.png' },
    'btn_replay':   { path: 'assets/ui/btn_replay.png' },
    'health_bar':  { path: 'assets/ui/health_bar.png' },
    'final_art':   { path: 'assets/ui/final_art.png' },
    'tut_game1':     { path: 'assets/ui/tut_game1.png' },
    'tut_game2':     { path: 'assets/ui/tut_game2.png' },
    'tut_game3':     { path: 'assets/ui/tut_game3.png' },
    'count_3':     { path: 'assets/ui/count_3.png' },
    'count_2':     { path: 'assets/ui/count_2.png' },
    'count_1':     { path: 'assets/ui/count_1.png' },
    'bgm_menu':    { path: 'assets/music/bg_menu.mp3' },
    'bgm_game1':   { path: 'assets/music/bg_game1.mp3' },
    'bgm_game2':   { path: 'assets/music/bg_game2.mp3' },
    'bgm_game3':   { path: 'assets/music/bg_game3.mp3' },
    'bgm_end':     { path: 'assets/music/bg_end.mp3' },
    'bg_game1':    { path: 'assets/game1/bg.png' },
    'hero_run':    { path: 'assets/game1/hero_run_', frames: 4 }, 
    'enemy_g':     { path: 'assets/game1/spike.png' },
    'enemy_a':     { path: 'assets/game1/bird_', frames: 2 },
    'bg_game2':    { path: 'assets/game2/bg.png' },
    'paddle':      { path: 'assets/game2/paddle.png' },
    'ball':        { path: 'assets/game2/ball.png' },
    'bg_game3':    { path: 'assets/game3/bg.png' },
    'item_good':   { path: 'assets/game3/cake.png' },
    'item_bad':    { path: 'assets/game3/bomb_', frames: 2 },
};

const loadedImages = {};

function preloadAllAssets(callback) {
    const startTime = Date.now();
    const assetKeys = Object.keys(ASSETS);
    let loadedCount = 0;

    function isAllLoaded() {
        loadedCount++;
        if(loadedCount >= assetKeys.length) {
            const elapsed = Date.now() - startTime;
            const minTime = 2000; // 2 seconds
            const delay = Math.max(0, minTime - elapsed);
            setTimeout(callback, delay);
        }
    }

    assetKeys.forEach(key => {
        const asset = ASSETS[key];
        if(asset.frames) {
            loadedImages[key] = [];
            for(let i=0; i<asset.frames; i++) {
                const img = new Image();
                img.src = `${asset.path}${i}.png`;
                img.onload = () => {
                    loadedImages[key][i] = img;
                    if(i === asset.frames - 1) isAllLoaded();
                };
            }
        } else if(asset.path.endsWith('.png') || asset.path.endsWith('.jpg') || asset.path.endsWith('.webp')) {
            const img = new Image();
            img.src = asset.path;
            img.onload = () => {
                loadedImages[key] = img;
                isAllLoaded();
            };
        } else {
            // skip non-image assets like audio
            isAllLoaded();
        }
    });
}


const Engine = {
    lastAnimTime: 0,
    audioCtx: null,
    currentTrack: null,
    currentTrackName: null,

    initAudio: function() {
        if(!this.audioCtx) {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if(this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
        }
    },

    playMusic: function(name) {
        const key = 'bgm_' + name;
        if(!ASSETS[key]) return;
        if(this.currentTrackName === name) return;
        if(this.currentTrack) {
            this.currentTrack.pause();
            this.currentTrack.currentTime = 0;
        }
        this.currentTrackName = name;
        this.currentTrack = new Audio(ASSETS[key].path);
        this.currentTrack.loop = true;
        this.currentTrack.volume = 0.4;
        this.currentTrack.play().catch(e => {
            console.log("Music waiting for interaction");
        });
    },

    playSFX: function(name, rate = 1.0) {
        try {
            this.initAudio();
            const osc = this.audioCtx.createOscillator();
            const gain = this.audioCtx.createGain();
            osc.connect(gain);
            gain.connect(this.audioCtx.destination);

            if(name === 'jump') { osc.frequency.value = 600; osc.type = 'square'; }
            else if(name === 'hit' || name === 'miss') { osc.frequency.value = 150; osc.type = 'sawtooth'; }
            else if(name === 'collect' || name === 'bounce') { osc.frequency.value = 880; osc.type = 'sine'; }
            else if(name === 'explode') { osc.frequency.value = 100; osc.type = 'sawtooth'; }
            else if(name === 'count') { osc.frequency.value = 440; osc.type = 'sine'; }
            else { osc.frequency.value = 440; osc.type = 'triangle'; }

            osc.frequency.value *= rate;

            osc.start();
            gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.00001, this.audioCtx.currentTime + 0.15);
            osc.stop(this.audioCtx.currentTime + 0.15);
        } catch(e) {}
    },
    
    loadAsset: function(el, key) {
        if(!loadedImages[key]) return; 
        el.dataset.key = key;
        el.dataset.frame = 0;

        if(ASSETS[key].frames) {
            el.style.backgroundImage = `url('${loadedImages[key][0].src}')`;
        } else {
            el.style.backgroundImage = `url('${loadedImages[key].src}')`;
        }

        el.classList.add('loaded');
        if(!el.classList.contains('btn')) {
            el.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) node.remove();
            });
        } else {
            el.style.color = 'transparent';
        }
    },
    
    animate: function(now) {
        if(now - this.lastAnimTime < 150) return; 
        this.lastAnimTime = now;

        document.querySelectorAll('.asset-box').forEach(el => {
            const key = el.dataset.key;
            if(!key || !ASSETS[key] || !ASSETS[key].frames) return;
            
            let f = parseInt(el.dataset.frame) + 1;
            if(f >= ASSETS[key].frames) f = 0;
            
            el.dataset.frame = f;
            el.style.backgroundImage = `url('${ASSETS[key].path}${f}.png')`;
        });
    }
};

const Game = {
    state: 'menu',
    activeGame: null,
    loopId: null,
    score: 0,
    totalScore: 0,
    health: 100,
    width: 0,
    height: 0,
    entities: [],
    combo: 0,

    init: function() {
        this.updateDimensions();
        window.addEventListener('resize', () => this.updateDimensions());
        
        document.getElementById('btn-start').onclick = (e) => {
            e.preventDefault(); e.stopPropagation();
            Engine.playSFX('click');
            this.totalScore = 0; // Reset total score when starting new game
            this.showTutorial('game1');
        };
        
        document.getElementById('btn-ready').onclick = (e) => {
            e.preventDefault(); e.stopPropagation();
            Engine.playSFX('click');
            this.startCountdown();
        };

        document.getElementById('btn-replay').onclick = () => {
            Engine.playSFX('click');
            location.reload();
        };

        // FIXED: Explicitly load the button assets here
        Engine.loadAsset(document.getElementById('btn-start'), 'btn_start');
        Engine.loadAsset(document.getElementById('btn-ready'), 'btn_ready');
        Engine.loadAsset(document.getElementById('btn-replay'), 'btn_replay');

        // Removed bg_start load
        Engine.loadAsset(document.getElementById('title-art'), 'title');
        Engine.loadAsset(document.getElementById('ui-health'), 'health_bar');
        Engine.loadAsset(document.getElementById('final-art'), 'final_art');
        
        Engine.playMusic('menu');
        this.menuLoop();
    },
    
    updateDimensions: function() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
    },
    
    menuLoop: function() {
        Engine.animate(Date.now());
        requestAnimationFrame(() => this.menuLoop());
    },

    // FIXED: Updated tutorial logic to use text instead of image
    showTutorial: function(gameName) {
        this.activeGame = gameName;
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        const tutorialScreen = document.getElementById('screen-tutorial');
        tutorialScreen.classList.add('active');
        
        // Set the game background on the tutorial screen
        const bgKey = 'bg_' + gameName;
        if(loadedImages[bgKey]) {
            tutorialScreen.style.backgroundImage = `url('${loadedImages[bgKey].src}')`;
        }
        
        const tutText = document.getElementById('tut-text');
        tutText.innerHTML = ''; // clear previous content

        let assetKey = '';
        if (gameName === 'game1') assetKey = 'tut_game1';
        else if (gameName === 'game2') assetKey = 'tut_game2';
        else if (gameName === 'game3') assetKey = 'tut_game3';

        // Create img element
        const img = document.createElement('img');
        img.style.maxWidth = '95%';
        img.style.height = 'auto';
        img.style.display = 'block';
        img.style.margin = '0 auto'; // center horizontally

        // Assign the preloaded src
        img.src = loadedImages[assetKey].src;

        // Append to tutorial container
        tutText.appendChild(img);



    },

    startCountdown: function() {
        const gameName = this.activeGame;
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        const screenGame = document.getElementById('screen-game');
        const gameWindow = document.getElementById('game-window');
        screenGame.classList.add('active');
        
        // Set game-specific background colors
        if(gameName === 'game1') {
            screenGame.style.backgroundColor = '#f6e6ff'; // Light purple (original)
        } else if(gameName === 'game2') {
            screenGame.style.backgroundColor = '#ede0ff'; // More violet
        } else if(gameName === 'game3') {
            screenGame.style.backgroundColor = '#f0e0f5'; // Reddish purple/violet
        }
        
        gameWindow.innerHTML = '';
        Engine.loadAsset(gameWindow, 'bg_' + gameName);
        Engine.playMusic(gameName);

        document.getElementById('hud').style.display = 'none';

        let count = 3;
        
        const tick = () => {
            if (count > 0) {
                Engine.playSFX('count');
                const numEl = document.createElement('div');
                numEl.className = 'asset-box count-anim jitter';
                numEl.style.position = 'absolute';
                numEl.style.left = '50%';
                numEl.style.top = '50%';
                numEl.style.width = '150px'; 
                numEl.style.height = '150px';
                numEl.style.transform = 'translate(-50%, -50%)';
                numEl.style.zIndex = '1000';
                
                Engine.loadAsset(numEl, 'count_' + count);
                gameWindow.appendChild(numEl);
                
                setTimeout(() => { if(numEl.parentNode) numEl.remove(); }, 900);
                
                count--;
                setTimeout(tick, 1000);
            } else {
                this.startGame(gameName, true);
            }
        };
        
        tick();
    },

    startGame: function(gameName, skipSetup = false) {
        this.updateDimensions();
        const gameWindow = document.getElementById('game-window');
        const gameWindowRect = gameWindow.getBoundingClientRect();
        this.gameWindowX = gameWindowRect.left;
        this.gameWindowY = gameWindowRect.top;
        this.gameWindowWidth = gameWindowRect.width;
        this.gameWindowHeight = gameWindowRect.height;
        
        if(!skipSetup) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-game').classList.add('active');
        }
        
        // Set game-specific background and timer colors
        const screenGame = document.getElementById('screen-game');
        const timerDiv = document.querySelector('.hud > div:last-child');
        
        if(gameName === 'game1') {
            screenGame.style.backgroundColor = '#f6e6ff'; // Light purple (original)
            timerDiv.style.color = '#8a6a9a'; // Original timer color
        } else if(gameName === 'game2') {
            screenGame.style.backgroundColor = '#ede0ff'; // More violet
            timerDiv.style.color = '#7a5a9a'; // More violet timer
        } else if(gameName === 'game3') {
            screenGame.style.backgroundColor = '#f0e0f5'; // Reddish purple/violet
            timerDiv.style.color = '#9a6a8a'; // Reddish purple timer
        }
        
        document.getElementById('hud').style.display = 'flex';
        
        this.state = 'playing';
        this.score = 0;
        this.health = 100;
        this.entities = [];
        this.combo = 0;
        
        window.onpointerdown = null;
        window.onkeydown = null;
        window.onpointermove = null;
        window.ontouchmove = null;
        
        if(!skipSetup) {
            gameWindow.innerHTML = '';
            Engine.loadAsset(gameWindow, 'bg_' + gameName);
            Engine.playMusic(gameName);
        }

        if(gameName === 'game1') this.initRunner();
        if(gameName === 'game2') this.initPong();
        if(gameName === 'game3') this.initCatcher();

        if(this.loopId) cancelAnimationFrame(this.loopId);
        this.loop();
    },

    loop: function() {
        if(this.state !== 'playing') return;

        this.score += 1/60;
        document.getElementById('timer').innerText = Math.floor(this.score);
        Engine.animate(Date.now());

        if(this.activeGame === 'game1') this.updateRunner();
        if(this.activeGame === 'game2') this.updatePong();
        if(this.activeGame === 'game3') this.updateCatcher();

        this.entities.forEach(e => {
            e.x += e.vx;
            e.y += e.vy;

            if(this.activeGame === 'game1' && e.type === 'enemy' && e.isAir) {
                e.y = e.initialY + Math.sin(this.score * 5) * 40; 
            }

            e.el.style.left = Math.round(e.x) + 'px';
            e.el.style.top = Math.round(e.y) + 'px';
        });

        document.getElementById('health-fill').style.width = Math.max(0, this.health * 0.9) + '%';
        
        if(this.health <= 0) {
            this.nextLevel();
        } else {
            this.loopId = requestAnimationFrame(() => this.loop());
        }
    },

    spawn: function(key, x, y, w, h, type) {
        const el = document.createElement('div');
        el.className = 'asset-box jitter';
        el.style.position = 'absolute';
        el.style.left = Math.round(x) + 'px';
        el.style.top = Math.round(y) + 'px';
        el.style.width = w + 'px';
        el.style.height = h + 'px';
        el.style.zIndex = '100'; // Ensure assets are above background
        Engine.loadAsset(el, key);
        document.getElementById('game-window').appendChild(el);
        const ent = { el, x, y, initialY: y, w, h, vx:0, vy:0, type, dead:false };
        this.entities.push(ent);
        return ent;
    },

    nextLevel: function() {
        cancelAnimationFrame(this.loopId);
        
        // Accumulate the current game's score into total
        this.totalScore += this.score;
        
        this.health = 100;
        this.state = 'menu';
        
        if(this.activeGame === 'game1') {
            Engine.playMusic('menu');
            this.showTutorial('game2');
        }
        else if(this.activeGame === 'game2') {
            Engine.playMusic('menu');
            this.showTutorial('game3');
        }
        else {
            Engine.playMusic('end');
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('hud').style.display = 'none';
            document.getElementById('screen-end').classList.add('active');
            document.getElementById('end-score').innerText = "Total Time: " + Math.floor(this.totalScore) + "s";
        }
    },

    // === GAME 1: RUNNER ===
    hero: null,
    timer: 0,
    groundY: 0,
    
    initRunner: function() {
        // INCREASED SIZE: Hero 100->150, moved left from 50 to 30 to 15 to 5
        this.groundY = this.gameWindowHeight * 0.85; 
        this.hero = this.spawn('hero_run', 5, this.groundY - 150, 150, 150, 'hero');
        this.hero.onGround = true;
        this.hero.jumpCount = 0; 
        this.timer = 120;
        
        const jumpAction = () => {
            if(this.state === 'playing' && this.hero) {
                if(this.hero.onGround || this.hero.jumpCount < 2) {
                    this.hero.vy = -22; 
                    this.hero.onGround = false;
                    this.hero.jumpCount++;
                    Engine.playSFX('jump', this.hero.jumpCount === 2 ? 1.5 : 1.0);
                }
            }
        };

        window.onpointerdown = (e) => {
            if(e.target.closest('.btn') || e.target.closest('.hud')) return;
            jumpAction();
        };
        
        window.onkeydown = (e) => {
            if(e.code === 'Space') jumpAction();
        };
    },
    
    updateRunner: function() {
        if(!this.hero) return;
        
        this.hero.vy += 0.9;
        
        // Updated for new size (150px)
        const targetGroundY = this.groundY - 150;
        
        if(this.hero.y >= targetGroundY && this.hero.vy >= 0) {
            this.hero.y = targetGroundY;
            this.hero.vy = 0;
            this.hero.onGround = true;
            this.hero.jumpCount = 0; 
        }
        
        this.timer--;
        if(this.timer <= 0) {
            const difficulty = Math.min(this.score / 60, 3);
            const isAir = Math.random() > 0.85;
            
            // INCREASED SIZE: Enemy 80->120. Adjusted spawn Y logic.
            const enemyY = isAir ? (this.groundY - 300) : (this.groundY - 120);
            
            const enemy = this.spawn(isAir ? 'enemy_a' : 'enemy_g', this.gameWindowWidth + 50, enemyY, 120, 120, 'enemy');
            enemy.isAir = isAir; 
            enemy.vx = -(4 + difficulty * 2); 
            this.timer = Math.max(40, 120 - difficulty * 20);
        }

        this.entities.forEach(e => {
            if(e.type === 'enemy') {
                if(e.x < -150) { e.dead = true; e.el.remove(); }
                
                // Adjusted collision for larger sizes
                const dx = Math.abs(this.hero.x + 75 - (e.x + 60));
                const dy = Math.abs(this.hero.y + 75 - (e.y + 60));
                
                if(!e.dead && dx < 100 && dy < 100) {
                    e.dead = true;
                    e.el.classList.add('pop');
                    setTimeout(() => e.el.remove(), 200);
                    this.health -= 25;
                    Engine.playSFX('hit');
                    document.body.classList.add('shake');
                    this.hero.el.classList.add('flash');
                    setTimeout(() => {
                        document.body.classList.remove('shake');
                        this.hero.el.classList.remove('flash');
                    }, 300);
                }
            }
        });
        
        this.entities = this.entities.filter(e => !e.dead || e.type === 'hero');
    },

    // === GAME 2: PONG ===
    paddle: null, 
    balls: [],
    ballSpawnTimer: 0,
    
    initPong: function() {
        const paddleHeight = 40;
        const paddleWidth = 140;
        const paddleY = this.gameWindowHeight - paddleHeight - 10;
        this.paddle = this.spawn('paddle', this.gameWindowWidth/2 - paddleWidth/2, paddleY, paddleWidth, paddleHeight, 'paddle');
    
        
        const ball = this.spawn('ball', this.gameWindowWidth/2 - 35, 100, 70, 70, 'ball');
        ball.vx = 4; ball.vy = 4;
        this.balls = [ball];
        this.ballSpawnTimer = 180;
        
        window.onpointermove = (e) => {
            if(this.paddle && this.state === 'playing') {
                const relativeX = e.clientX - this.gameWindowX;
                this.paddle.x = Math.max(0, Math.min(this.gameWindowWidth - 180, relativeX - 90));
            }
        };
        
        window.ontouchmove = (e) => {
            if(this.paddle && this.state === 'playing') {
                e.preventDefault();
                const relativeX = e.touches[0].clientX - this.gameWindowX;
                this.paddle.x = Math.max(0, Math.min(this.gameWindowWidth - 180, relativeX - 90));
            }
        };
    },
    
    updatePong: function() {
        if(!this.paddle || this.balls.length === 0) return;
        const difficulty = Math.min(this.score / 25, 3);
        
        this.ballSpawnTimer--;
        if(this.ballSpawnTimer <= 0 && this.balls.length < 10) {
            const newBall = this.spawn('ball', Math.random() * (this.gameWindowWidth - 60), 100, 60, 60, 'ball');
            newBall.vx = (Math.random() - 0.5) * 8;
            newBall.vy = 4 + difficulty;
            this.balls.push(newBall);
            this.ballSpawnTimer = Math.max(180, 300 - difficulty * 40);
        }
        
        this.balls.forEach(ball => {
            if(ball.dead) return;
            
            if(ball.x < 0 || ball.x > this.gameWindowWidth - 60) {
                ball.vx *= -1;
                ball.x = Math.max(0, Math.min(this.gameWindowWidth - 60, ball.x));
            }
            if(ball.y < 60) {
                ball.vy *= -1;
                ball.y = 60;
            }
            
            const ballBottom = ball.y + 60;
            const ballCenterX = ball.x + 30;
            
            // Adjusted collision for new sizes
            if(ballBottom >= this.paddle.y && ballBottom <= this.paddle.y + 40 &&
               ballCenterX >= this.paddle.x && ballCenterX <= this.paddle.x + 180) {
                
                const paddleCenter = this.paddle.x + 90;
                const hitOffset = (ballCenterX - paddleCenter) / 90; 
                
                ball.vx = hitOffset * 10; 
                ball.vy = -Math.abs(ball.vy * 1.05); 
                ball.y = this.paddle.y - 60;
                
                Engine.playSFX('bounce', 1.0 + Math.abs(hitOffset)); 
                this.paddle.el.classList.add('flash');
                setTimeout(() => this.paddle.el.classList.remove('flash'), 200);
            }
            
            if(ball.y > this.gameWindowHeight) {
                ball.dead = true; ball.el.remove();
                this.health -= 15;
                Engine.playSFX('miss');
                document.body.classList.add('shake');
                setTimeout(() => document.body.classList.remove('shake'), 300);
            }
        });
        
        this.balls = this.balls.filter(b => !b.dead);
        if(this.balls.length === 0) {
            const ball = this.spawn('ball', this.gameWindowWidth/2 - 30, 100, 60, 60, 'ball');
            ball.vx = 4;
            ball.vy = 4 + difficulty;
            this.balls = [ball];
        }
    },

    // === GAME 3: CATCHER ===
    initCatcher: function() {
        this.timer = 90;
        this.combo = 0;
    },
    
    updateCatcher: function() {
        this.timer--;
        if(this.timer <= 0) {
            const difficulty = Math.min(this.score / 40, 2.5);
            const isGood = Math.random() > 0.35;
            
            // INCREASED SIZE: Items 100->130
            const obj = this.spawn(isGood ? 'item_good' : 'item_bad', Math.random() * (this.gameWindowWidth - 130), -130, 130, 130, isGood ? 'good' : 'bad');
            
            const baseSpeed = 2.0 + difficulty * 1.2;
            const randomVar = (Math.random() * 2) - 0.5; 
            obj.vy = Math.max(1, baseSpeed + randomVar);
            
            obj.el.style.cursor = 'pointer';
            
            const hitHandler = (e) => {
                e.stopPropagation();
                if(!obj.dead) {
                    obj.dead = true;
                    obj.el.classList.add('pop');
                    setTimeout(() => obj.el.remove(), 200);
                    if(isGood) {
                        obj.el.style.transform = 'scale(1.5)';
                        this.combo++;
                        const pitch = Math.min(2.0, 1.0 + (this.combo * 0.1));
                        Engine.playSFX('collect', pitch);
                        
                    } else { 
                        this.health -= 25;
                        this.combo = 0;
                        Engine.playSFX('explode');
                        document.body.classList.add('shake');
                        setTimeout(() => document.body.classList.remove('shake'), 300);
                    }
                }
            };
            
            obj.el.onpointerdown = hitHandler;

            this.timer = Math.max(25, 90 - difficulty * 18);
        }
        
        this.entities.forEach(e => {
            if((e.type === 'good' || e.type === 'bad') && e.y > this.gameWindowHeight) {
                if(!e.dead && e.type === 'good') {
                    this.health -= 15;
                    this.combo = 0;
                    Engine.playSFX('miss');
                    document.body.classList.add('shake');
                    setTimeout(() => document.body.classList.remove('shake'), 300);
                }
                e.dead = true; e.el.remove();
            }
        });
        this.entities = this.entities.filter(e => !e.dead);
    }
};

window.onload = () => {
    // Load the loading image first
    const loadingImg = new Image();
    loadingImg.src = 'assets/ui/loading.png';
    loadingImg.onload = () => {
        loadedImages['loading'] = loadingImg;
        const loadingAsset = document.getElementById('loading-asset');
        if(loadingAsset) {
            Engine.loadAsset(loadingAsset, 'loading');
        }
    };
    
    preloadAllAssets(() => {
        console.log('All assets preloaded!');
        document.getElementById('screen-loading').classList.remove('active');
        document.getElementById('screen-start').classList.add('active');

        Game.init();
    });
};

</script>
<link rel="preload" as="image" href="assets/ui/btn_start.png">
<link rel="preload" as="image" href="assets/ui/btn_ready.png">
<link rel="preload" as="image" href="assets/ui/title.png">
</body>
</html>
